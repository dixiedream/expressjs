{
  "Error module": {
    "scope": "javascript,typescript",
    "prefix": "error",
    "body": [
      "/**",
      " * Created by Alessandro Lucarini",
      " * Date: ${CURRENT_DATE}/${CURRENT_MONTH}/${CURRENT_YEAR}",
      " * Time: ${CURRENT_HOUR}:${CURRENT_MINUTE}",
      " */",
      "const APIError = require(\"../APIError\");",
      "",
      "module.exports = class ${1:moduleName} extends (APIError) {",
      "  constructor(message) {",
      "    super(message || \"${2:errorMessage}\");",
      "  }",
      "};",
      "",
      "",
      ""
    ],
    "description": "Error module"
  },
  "Mongoose Model": {
    "prefix": "model",
    "body": [
      "/**",
      " * Created by Alessandro Lucarini",
      " * Date: ${CURRENT_DATE}/${CURRENT_MONTH}/${CURRENT_YEAR}",
      " * Time: ${CURRENT_HOUR}:${CURRENT_MINUTE}",
      " */",
      "const Joi = require(\"joi\");",
      "const mongoose = require(\"mongoose\");",
      "",
      "const { Schema } = mongoose;",
      "",
      "const ${1:moduleName}Schema = new Schema({",
      "  /* ",
      "   * Schema definition  ",
      "   * email: {",
      "   * type: String,",
      "   * unique: true,",
      "   * required: true",
      "   * }...",
      "   */",
      "});",
      "",
      "exports.${1:moduleName} = mongoose.model(\"${1:moduleName}\", ${1:moduleName}Schema);",
      "// Client input validation method",
      "exports.validate = model => {",
      "  const joiModel = Joi.object({",
      "    /*",
      "     * Joi schema definition",
      "     * email: Joi.string()",
      "     *   .min(5)",
      "     *   .max(255)",
      "     *   .required()",
      "     *   .email(),",
      "     * ...",
      "     */  ",
      "  });",
      "",
      "  return joiModel.validate(model);",
      "};",
      ""
    ],
    "description": "Mongoose Model"
  },
  "Route file": {
    "prefix": "routefile",
    "body": [
      "/**",
      " * Created by Alessandro Lucarini",
      " * Date: ${CURRENT_DATE}/${CURRENT_MONTH}/${CURRENT_YEAR}",
      " * Time: ${CURRENT_HOUR}:${CURRENT_MINUTE}",
      " */",
      "const router = require(\"express\").Router();",
      "const APIError = require(\"../../shared/errors/APIError\");",
      "const NotFoundError = require(\"../../shared/errors/NotFoundError\");",
      "const logger = require(\"../../config/logger\");",
      "const auth = require(\"../../middleware/auth\");",
      "const validateObjectId = require(\"../../middleware/validateObjectId\");",
      "const ${1:controllerName} = require(\"../controllers/${1:controllerName}\");",
      "",
      "// Authenticated route",
      "router.get(\"/:id\", [auth, validateObjectId], (req, res) => {",
      "  logger.info(\"${3:errorEventName}_REQUEST\", { ${2:queryResult}: req.params.id });",
      "  ${1:controllerName}",
      "    .read(req.params.id)",
      "    .then(${2:queryResult} => {",
      "      logger.info(\"${3:errorEventName}_REQUEST_SUCCEEDED\", { ${2:queryResult} });",
      "      res.status(200).send(${2:queryResult});",
      "    })",
      "    .catch(err => {",
      "      logger.error(\"${3:errorEventName}_REQUEST_FAILED\", err);",
      "      if (err instanceof NotFoundError) {",
      "        const { type, message } = err;",
      "        res.status(404).send({ type, message });",
      "      } else if (err instanceof APIError) {",
      "        const { type, message } = err;",
      "        res.status(400).send({ type, message });",
      "      } else {",
      "        res.status(500).send();",
      "      }",
      "    });",
      "});",
      "",
      "// Not authenticated route",
      "router.get(\"/\", (req, res) => {",
      "  logger.info(\"${3:errorEventName}S_REQUEST\", { body: req.body });",
      "  ${1:controllerName}",
      "    .index()",
      "    .then(${2:queryResult}s => {",
      "      logger.info(\"${3:errorEventName}S_REQUEST_SUCCEEDED\", { ${2:queryResult}s });",
      "      res.status(200).send(${2:queryResult}s);",
      "    })",
      "    .catch(err => {",
      "      logger.error(\"${3:errorEventName}S_REQUEST_FAILED\", err);",
      "      if (err instanceof APIError) {",
      "        const { type, message } = err;",
      "        res.status(400).send({ type, message });",
      "      } else {",
      "        res.status(500).send();",
      "      }",
      "    });",
      "});",
      "",
      "module.exports = router;",
      ""
    ],
    "description": "Route file"
  },
  "Controller": {
    "prefix": "controller",
    "body": [
      "/**",
      " * Created by Alessandro Lucarini",
      " * Date: ${CURRENT_DATE}/${CURRENT_MONTH}/${CURRENT_YEAR}",
      " * Time: ${CURRENT_HOUR}:${CURRENT_MINUTE}",
      " */",
      "const { ${1:modelName}, validate } = require(\"../models/${1:modelName}\");",
      "const InvalidDataError = require(\"../../shared/errors/InvalidDataError\");",
      "",
      "module.exports = {",
      "  create: async body => {",
      "    const { error } = validate(body);",
      "    if (error) {",
      "      throw new InvalidDataError(error.details[0].message);",
      "    }",
      "  },",
      "  read: async id => {},",
      "  update: async (body, id) => {",
      "    const { error } = validate(body);",
      "    if (error) {",
      "      throw new InvalidDataError(error.details[0].message);",
      "    }",
      "  },",
      "  index: async () => {},",
      "  delete: async id => {}",
      "};"
    ],
    "description": "Controller"
  },
  "Integration test class": {
    "prefix": "integrationTestClass",
    "body": [
      "/**",
      " * Created by Alessandro Lucarini",
      " * Date: ${CURRENT_DATE}/${CURRENT_MONTH}/${CURRENT_YEAR}",
      " * Time: ${CURRENT_HOUR}:${CURRENT_MINUTE}",
      " */",
      "const request = require(\"supertest\");",
      "const mongoose = require(\"mongoose\");",
      "",
      "const server = require(\"../../app\");",
      "const endpoint = \"/api/${1:controllerName}\";",
      "",
      "describe(endpoint, () => {",
      "  afterAll(async () => {",
      "    const { connections } = mongoose;",
      "    connections.forEach(con => {",
      "      return con.close();",
      "    });",
      "    await mongoose.disconnect();",
      "  });",
      "",
      "  describe(\"POST /\", () => {",
      "    /**",
      "     * Define body parameters here for handy reuse",
      "     * es: let email;",
      "     */",
      "",
      "    const exec = async () => {",
      "      return request(server)",
      "        .post(endpoint)",
      "        .send(); // Pass your body request parameters here like an object es: { email }",
      "    };",
      "",
      "    it(\"should return 400 if empty request body\", async () => {",
      "      const res = await exec();",
      "      expect(res.status).toBe(400);",
      "    });",
      "  });",
      "",
      "  describe(\"GET /\", () => {",
      "    /**",
      "     * Define body parameters here for handy reuse",
      "     * es: let email;",
      "     */",
      "",
      "    const exec = async () => {",
      "      return request(server)",
      "        .get(endpoint)",
      "        .send(); // Pass your body request parameters here like an object es: { email }",
      "    };",
      "",
      "    it(\"should return 400 if empty request body\", async () => {",
      "      const res = await exec();",
      "      expect(res.status).toBe(400);",
      "    });",
      "  });",
      "",
      "  describe(\"GET /:id\", () => {",
      "    let ${2:modelName}Id;",
      "",
      "    const exec = async () => {",
      "      return request(server)",
      "        .get(`${endpoint}/${${2:modelName}Id}`)",
      "        .send();",
      "    };",
      "",
      "    it(\"should return 404 if ${2:modelName} not exists\", async () => {",
      "      ${2:modelName}Id = mongoose.Types.ObjectId();",
      "      const res = await exec();",
      "      expect(res.status).toBe(400);",
      "    });",
      "",
      "    it(\"should return 400 if missing id parameter\", async () => {",
      "      ${2:modelName}Id = undefined;",
      "      const res = await exec();",
      "      expect(res.status).toBe(400);",
      "    });",
      "  });",
      "",
      "  describe(\"PUT /:id\", () => {",
      "    /**",
      "     * Define body parameters here for handy reuse",
      "     * es: let email;",
      "     */",
      "    let ${2:modelName}Id;",
      "",
      "    const exec = async () => {",
      "      return request(server)",
      "        .put(`${endpoint}/${${2:modelName}Id}`)",
      "        .send(); // Pass your body request parameters here like an object es: { email }",
      "    };",
      "",
      "    it(\"should return 400 if missing id parameter\", async () => {",
      "      ${2:modelName}Id = undefined;",
      "      const res = await exec();",
      "      expect(res.status).toBe(400);",
      "    });",
      "  });",
      "",
      "  describe(\"PATCH /:id\", () => {",
      "    /**",
      "     * Define body parameters here for handy reuse",
      "     * es: let email;",
      "     */",
      "    let ${2:modelName}Id;",
      "",
      "    const exec = async () => {",
      "      return request(server)",
      "        .patch(`${endpoint}/${${2:modelName}Id}`)",
      "        .send(); // Pass your body request parameters here like an object es: { email }",
      "    };",
      "",
      "    it(\"should return 400 if missing id parameter\", async () => {",
      "      ${2:modelName}Id = undefined;",
      "      const res = await exec();",
      "      expect(res.status).toBe(400);",
      "    });",
      "  });",
      "",
      "  describe(\"DELETE /:id\", () => {",
      "    let ${2:modelName}Id;",
      "",
      "    const exec = async () => {",
      "      return request(server)",
      "        .delete(`${endpoint}/${${2:modelName}Id}`)",
      "        .send();",
      "    };",
      "",
      "    it(\"should return 400 if missing id parameter\", async () => {",
      "      ${2:modelName}Id = undefined;",
      "      const res = await exec();",
      "      expect(res.status).toBe(400);",
      "    });",
      "  });",
      "});",
      ""
    ],
    "description": "Integration test class"
  },
  "Integration test function": {
    "prefix": "integrationTestFunction",
    "body": [
      "it(\"should return ${1:statusCode} if ${2:condition}\", async () => {",
      "  const res = await exec();",
      "  expect(res.status).toBe(${1:statusCode});",
      "});"
    ],
    "description": "Integration test function"
  }
}
